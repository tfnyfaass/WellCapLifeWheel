<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
    canvas {
      display: block;
      background-color: white;
    }
  </style>
</head>
<body>
<canvas id="lifeWheel" width="500" height="480"></canvas>

<script>
  const canvas = document.getElementById('lifeWheel');
  const ctx = canvas.getContext('2d');
  const centerX = canvas.width / 2;
  const centerY = canvas.height / 2 - 10;
  const maxRadius = 180;
  const levels = 5;
  const categories = [
    "Spiritual", "Learning", "Career", "Financial",
    "Leisure", "Health", "Family", "Social"
  ];
  const angleStep = (2 * Math.PI) / categories.length;
  const userSelections = new Array(categories.length).fill(0);
  let showWarning = false;

  const colors = {
    light: "#8ECAE6",
    mid: "#219EBC",
    dark: "#023047",
    stroke: "#219EBC",
    text: "#023047",
    alertText: "#FB8500"
  };

  function drawWheel() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Decorative solid center (not clickable)
    ctx.beginPath();
    ctx.arc(centerX, centerY, 14, 0, 2 * Math.PI);
    ctx.fillStyle = colors.text;
    ctx.fill();

    for (let i = 0; i < categories.length; i++) {
      for (let j = 0; j < levels; j++) {
        const innerR = (j / levels) * maxRadius;
        const outerR = ((j + 1) / levels) * maxRadius;
        const startAngle = i * angleStep;
        const endAngle = (i + 1) * angleStep;

        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.arc(centerX, centerY, outerR, startAngle, endAngle);
        ctx.arc(centerX, centerY, innerR, endAngle, startAngle, true);
        ctx.closePath();

        let fillColor = "#ffffff";
        if (userSelections[i] > j) {
          fillColor = j >= 4 ? colors.dark : j >= 2 ? colors.mid : colors.light;
        }
        ctx.fillStyle = fillColor;
        ctx.fill();

        ctx.strokeStyle = colors.stroke;
        ctx.lineWidth = 1.2;
        ctx.stroke();

        const midAngle = (startAngle + endAngle) / 2;
        const labelRadius = (innerR + outerR) / 2;
        const x = centerX + labelRadius * Math.cos(midAngle);
        const y = centerY + labelRadius * Math.sin(midAngle);

        ctx.fillStyle = (fillColor === colors.dark) ? "#ffffff" : colors.text;
        ctx.font = "12px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(j + 1, x, y);
      }
    }

    // Category labels
    ctx.fillStyle = colors.text;
    ctx.font = "12px Arial";
    for (let i = 0; i < categories.length; i++) {
      const angle = (i + 0.5) * angleStep;
      const labelRadius = maxRadius + 35;
      const x = centerX + labelRadius * Math.cos(angle);
      const y = centerY + labelRadius * Math.sin(angle);
      ctx.fillText(categories[i], x, y);
    }

    // Total score
    ctx.fillStyle = colors.text;
    ctx.font = "bold 14px Arial";
    ctx.textAlign = "left";
    ctx.fillText("Total: " + totalScore() + " / 25", 10, 22);

    // Warning message
    if (showWarning) {
      ctx.fillStyle = colors.alertText;
      ctx.font = "bold 14px Arial";
      ctx.textAlign = "center";
      ctx.fillText("âš  Total score cannot exceed 25", centerX, canvas.height - 10);
    }
  }

  function getSegmentFromCoords(x, y) {
    const dx = x - centerX;
    const dy = y - centerY;
    const angle = (Math.atan2(dy, dx) + 2 * Math.PI) % (2 * Math.PI);
    const distance = Math.sqrt(dx * dx + dy * dy);
    const categoryIndex = Math.floor(angle / angleStep);
    const level = Math.ceil((distance / maxRadius) * levels);
    if (level >= 1 && level <= levels) {
      return { categoryIndex, level };
    }
    return null;
  }

  function totalScore() {
    return userSelections.reduce((a, b) => a + b, 0);
  }

  canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const segment = getSegmentFromCoords(x, y);
    if (segment) {
      const currentTotal = totalScore();
      const currentVal = userSelections[segment.categoryIndex];
      const proposedVal = segment.level;
      const newTotal = currentTotal - currentVal + proposedVal;

      if (newTotal > 25) {
        showWarning = true;
        drawWheel();
        setTimeout(() => {
          showWarning = false;
          drawWheel();
        }, 2000);
        return;
      }

      userSelections[segment.categoryIndex] = segment.level;
      drawWheel();
    }
  });

  drawWheel();
</script>
</body>
</html>

